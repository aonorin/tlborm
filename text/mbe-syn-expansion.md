% Развертывание

Развертывание - это относительно несложна штука. В какой-то момент *после* создания AST, но перед тем, как начать создавать семантическое представление программы, компилятор развернет все макросы.

Этот процесс включает в себя проход AST, определение мест вызовов макросов и замены их на развертывание.  В случае расширений синтаксиса, не связанных с макросами, то,*как* компилятор их разворачивает, завсисит от самих синтаксических расширений. Таким образом, расширения синтаксиса проходят через  *точно такой же* процесс развертывания, как и макросы.

Когда компилятор запускает расширение синтаксиса, он ожидает, что результат можно будет распарсить в синтаксический элемент из известного ему списка, основываясь на контексте.  Например, если вы вызываете макрос в границах видимости модуля, компилятор распарсит результат в узел AST, представляющий элемент.  Если вызвать макрос на позиции выражения, компилятор распарсит результат в узел AST, представляющий выражение.

На самом деле, он может распарсить результат расширения синтаксиса в одно из следующих:

* выражение,
* паттерн,
* ноль или больше элементов,
* ноль или больше элементов `impl` , или
* ноль или больше утверждений.

Другими словами, то, *где* вы можете вызвать макрос, определятся результатом, в который он разворачивается.

Компилятор берет узел AST и полностью заменяет узел вызова макроса, на то, во что он разворачивается.  *Это структурная операция*, а не текстовая!

Например у нас есть следующее:

```ignore
let eight = 2 * four!();
```

Мы можем изобразить часть AST таким образом:

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
```

Из контекста, `four!()` *должен* развернуться в выражение (инициализаторы могут быть *только* выражением). Поэтому, чем бы ни было реальное развертывание, оно будет интерпретироваться как законченное выражение. В данном случае мы подразумеваем, что  `four!` определено так, что разворачивается в выражение `1 + 3`.  В результате, после развертывания вызов можно изобразить так:

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
```

Можно также написать это так:

```ignore
let eight = 2 * (1 + 3);
```

Заметьте, что мы добавили скобки, *несмотря на то, что* их не было в развертывании.  Помните, что компилятор всегда трактует развертывание макроса, как законченный узел AST, **не** как простую последовательность токенов. По-другому, даже если вы не обернули сложное выражение в скобки, компилятор все равно "правильно" интерпретирует результат или поменяет порядок оценки.

Важно понимать, что развертывание макроса считается узлами AST. У такого дизайна следующие следствия:

* В дополнении к тому, что есть ограниченный набор *мест вызовов*, макросы могут разворачиваться *только* в тот тип узла AST, который *ожидает* парсер в этом месте.
* В завершении вышесказанного - макросы *никогда не* могут развернуться в незаконченное выражение или синтаксически неправильную конструкцию.

Нужно знать еще одну вещь про развертывание: что происходит, если расширение синтаксиса разворачивается во что-то, содержащее  *другой* вызов расширения синтаксиса. Например, определим другое описание `four!`; что произойдет, если он развернется в `1 + three!()`?

```ignore
let x = four!();
```

Разворачивается в:

```ignore
let x = 1 + three!();
```

Компилятор ищет в получившемся результате развертывания дополнительные вызовы макросов и разворачивает их.  Поэтому после второго развертывания получится следующее:

```ignore
let x = 1 + 3;
```

Вынести из этого можно следующее - развертывание осуществляется "проходами"; столько, сколько нужно, чтобы полностью развернуть все вызовы.

Хотя, *немного не так*.  На самом деле компилятор лимитирует количество таких рекурсивных проходов, которые он выполнит перед тем, как сдасться. Это называется лимит рекурсии макросов и, по умолчанию, равен 32.  Если 32 развертывание содержит вызов макроса, компилятор прервет свою работу с ошибкой, сообщающей, что лимит рекурсии исчерпан.

Этот лимит можно увеличить через атрибут `#![recursion_limit="…"]`, однако это *необходимо* делать по всему контейнеру. Обычно, рекомендуется пробовать и пытаться удерживать макросы внутри этого лимита, где это только возможно.
