% Развертывание

Развертывание - это относительно несложная штука. В какой-то момент *после*
создания AST, но перед тем, как начать создавать семантическое представление
программы, компилятор развернет все макросы.

Этот процесс включает в себя проход AST, определение мест вызовов макросов и
замены их на развертывание.  В случае расширений синтаксиса, не связанных с
макросами, то ,*как* компилятор их разворачивает, зависит от самих синтаксических
расширений. Таким образом, расширения синтаксиса проходят через  *точно такой
же* процесс развертывания, как и макросы.

Когда компилятор запускает расширение синтаксиса, он ожидает, что результат
можно будет разобрать в синтаксический элемент из известного ему списка,
основываясь на контексте.  Например, если вы вызываете макрос в границах
видимости модуля, компилятор разберет результат в узел AST, представляющий
элемент.  Если вызвать макрос на позиции выражения, компилятор разберет
результат в узел AST, представляющий выражение.

На самом деле, он может разобрать результат расширения синтаксиса в одно из
следующих:

* выражение,
* паттерн,
* ноль или больше элементов,
* ноль или больше элементов `impl`,
* ноль или больше утверждений.

Другими словами, то, *где* вы можете вызвать макрос, определятся результатом, в
который он разворачивается.

Компилятор берет узел AST и полностью заменяет узел вызова макроса, на то, во
что он разворачивается.  *Это структурная операция*, а не текстовая!

Например у нас есть следующее:

```ignore
let eight = 2 * four!();
```

Мы можем изобразить часть AST таким образом:

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
```

Из контекста, `four!()` *должен* развернуться в выражение (инициализаторы могут
быть *только* выражением). Поэтому, чем бы ни было реальное развертывание, оно
будет интерпретироваться как законченное выражение. В данном случае мы
подразумеваем, что  `four!` определено так, что разворачивается в выражение `1 +
3`.  В результате, после развертывания вызов можно изобразить так:

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
```

Можно также написать это так:

```ignore
let eight = 2 * (1 + 3);
```

Заметьте, что мы добавили скобки, *несмотря на то, что* их не было в
развертывании.  Помните, что компилятор всегда трактует развертывание макроса,
как законченный узел AST, **не** как простую последовательность токенов. По-
другому, даже если вы не обернули сложное выражение в скобки, компилятор все
равно "правильно" интерпретирует результат или поменяет порядок вычисления.

Важно понимать, что развертывание макроса считается узлами AST. У такого дизайна
следующие следствия:

* В дополнении к тому, что есть ограниченный набор *мест вызовов*, макросы могут
 разворачиваться *только* в тот тип узла AST, который *ожидает парсер* в этом
 месте. 
* В завершении вышесказанного - макросы *никогда* не могут развернуться в
 незаконченное выражение или синтаксически неправильную конструкцию.

Нужно знать еще одну вещь про развертывание: что происходит, если расширение
синтаксиса разворачивается во что-то, содержащее  *другой* вызов расширения
синтаксиса. Например, определим другое описание `four!`; что произойдет, если он
развернется в `1 + three!()`?

```ignore
let x = four!();
```

Разворачивается в:

```ignore
let x = 1 + three!();
```

Компилятор ищет в получившемся результате развертывания дополнительные вызовы
макросов и разворачивает их. Поэтому после второго развертывания получится
следующее:

```ignore
let x = 1 + 3;
```

Вынести из этого можно следующее - развертывание осуществляется "проходами";
столько, сколько нужно, чтобы полностью развернуть все вызовы.

Хотя, *немного не так*.  На самом деле компилятор ограничивает количество таких
рекурсивных проходов, которые он выполнит перед тем, как сдастся. Это называется
лимит рекурсии макросов и, по умолчанию, равен 32. Если 32-ое развёртывание
содержит вызов макроса, компилятор прервет свою работу с ошибкой, сообщающей,
что лимит рекурсии исчерпан.

Этот лимит можно увеличить через атрибут `#![recursion_limit="…"]`, однако это
*необходимо* делать для всего контейнера. Обычно, рекомендуется стараться 
удерживать макросы в этих границах.
