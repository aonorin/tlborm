% Последовательный потребитель TT

```rust
macro_rules! mixed_rules {
    () => {};
    (trace $name:ident; $($tail:tt)*) => {
        {
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
    (trace $name:ident = $init:expr; $($tail:tt)*) => {
        {
            let $name = $init;
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
}
# 
# fn main() {
#     let a = 42;
#     let b = "Ho-dee-oh-di-oh-di-oh!";
#     let c = (false, 2, 'c');
#     mixed_rules!(
#         trace a;
#         trace b;
#         trace c;
#         trace b = "They took her where they put the crazies.";
#         trace b;
#     );
# }
```

Этот паттерн - возможно *самая мощная* доступная техника разбора макросов,
позволяющая разбирать грамматику любой сложности.

"Потребитель TT" - это рекурсивный макрос, который работает, последовательно
обрабатывая шаг за шагом то, что ему подали на вход. На каждом шаге он ищет
совпадение и удаляет (потребляет) сочетание токенов из головы входа, создает
какой-то промежуточный результат, затем вызывает сам себя с оставшейся частью
входа в качестве аргумента.

Причина по которой "TT" указано в имени  - необработанная часть входа *всегда*
захватывается как `$($tail:tt)*`. Делается это, потому что повторение `tt` - это
единственный способ *без потерь* захватить часть входа макроса.

Единственными жесткими ограничениями, которые накладываются на потребитель TT,
являются те же, что и на всю систему макросов в целом:

* Вы можете использовать совпадение только с литералами или грамматическими
конструкциями, которые могут захватываться `macro_rules!`.

* Вы не можете использовать совпадение с несбалансированной группой.

Важно, однако, помнить о лимите рекурсии макросов. `macro_rules!` не обладает
*никакой* формой устранения или оптимизации хвостовой рекурсии. При написании
потребителя TT рекомендуется предпринимать все усилия, чтобы удержаться в лимите
рекурсии. Можно сделать это, добавляя дополнительные правила для учета вариантов
входа (что противоположно использованию рекурсии в промежуточном слое), или, идя
на компромиссы, и подгоняя вход под использования стандартных повторений.
