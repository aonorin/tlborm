% Последовательный потребитель TT

```rust
macro_rules! mixed_rules {
    () => {};
    (trace $name:ident; $($tail:tt)*) => {
        {
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
    (trace $name:ident = $init:expr; $($tail:tt)*) => {
        {
            let $name = $init;
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
}
# 
# fn main() {
#     let a = 42;
#     let b = "Ho-dee-oh-di-oh-di-oh!";
#     let c = (false, 2, 'c');
#     mixed_rules!(
#         trace a;
#         trace b;
#         trace c;
#         trace b = "They took her where they put the crazies.";
#         trace b;
#     );
# }
```

Этот паттерн - возможно *самая мощная* доступная техника парсинга макросов, позволяющая парсить грамматику любой сложности.

"Потребитель TT" - это рекурсивный макрос, который работает, последовательно обрабатывая шаг за шагом то, что ему подали на вход. На каждом шаге он ищет совпадение и удаляет (потребляет) сочетание токенов из головы входа, создает какой-то промежуточный результат, затем рекурсивно вызывает оставшуюся часть входа.

Причина по которой "TT" указано в имени  - необработанная часть входа *всегда* захватывается как `$($tail:tt)*`. Делается это, потому что повторение `tt` - это единственный способ *без потерь* захватить часть входа макроса.

Единственными жесткими ограничениями, которые накладываются на пожиратель TT, являются те же, что и на всю систему макросов в целом:

* Вы можете использовать совпадение только с литералами или грамматическими конструкций, которые могут захватываться `macro_rules!`.
* Вы не можете использовать совпадение с несбалансированной группой.

Важно, однако, помнить о лимите рекурсии макросов. `macro_rules!` не обладает *никакой* формой устранения или оптимизации хвостовой рекурсии. Рекомендуется, при написании потребителя TT, предпринимать все усилия, чтобы удержаться в лимите рекурсии. Можно сделать это, добавляя дополнительные правила для учета вариантов входа (что противоположно использованию рекурсии в промежуточном слое), или, идя на компромиссы, и подгоняя вход под использования стандартных повторений.
