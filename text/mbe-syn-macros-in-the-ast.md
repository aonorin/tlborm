% Макросы в AST

Как раньше отмечалось, обработка макросов в Rust происходит *после* построения
AST. Поэтому синтаксис, используемый для вызова макроса, *должен быть*
собственной частью синтаксиса языка. На самом деле, есть несколько форм
"расширений синтаксиса", которые являются частью синтаксиса Rust. Конкретно,
следующие формы (с примерами):

* `# [ $arg ]`; *например* `#[derive(Clone)]`, `#[no_mangle]`, …
* `# ! [ $arg ]`; *например* `#![allow(dead_code)]`, `#![crate_name="blang"]`, …
* `$name ! $arg`; *например* `println!("Hi!")`, `concat!("a", "b")`, …
* `$name ! $arg0 $arg1`; *например* `macro_rules! dummy { () => {}; }`.

Первые две -  "атрибуты" и относятся как к специальными конструкциями языка
(такие как `#[repr(C)]`, которая используется при запросе C-совместимого ABI для
пользовательского типа) так и синтаксическим расширениями (такие как
`#[derive(Clone)]`).  В данный момент нет возможности определить макрос, который
бы использовал эти формы.

Именно третья форма представляет для нас интерес: это форма, доступная для
использования макросов. Помните, что она не *ограничена* только для макросов:
это общая синтаксическая форма расширения.  Например, если `format!` - это
макрос, `format_args!` (которая используется для  *реализации* `format!`) -
*нет*.

Четвертая форма - это по существу вариация, которая *недоступна* для макросов.
На самом деле, *единственным* местом, где она используется является
`macro_rules!`, к которому мы еще вернемся.

Игнорируя все кроме третьей формы (`$name ! $arg`), встает вопрос: откуда парсер
Rust знает, как выглядит `$arg` для всех возможных расширения синтаксиса?  Ответ
заключается в том, что ему и *не нужно* это. Вместо этого, аргументом вызова
расширения синтаксиса является *одиночное* дерево токенов. Говоря более
конкретно, это одиночное, *безлистное* дерево токенов; `(...)`, `[...]`, или
`{...}`.  Обладая этими знаниями, должно быть ясно, как парсер может разобрать
все эти формы вызова:

```ignore
bitflags! {
    flags Color: u8 {
        const RED    = 0b0001,
        const GREEN  = 0b0010,
        const BLUE   = 0b0100,
        const BRIGHT = 0b1000,
    }
}

lazy_static! {
    static ref FIB_100: u32 = {
        fn fib(a: u32) -> u32 {
            match a {
                0 => 0,
                1 => 1,
                a => fib(a-1) + fib(a-2)
            }
        }

        fib(100)
    };
}

fn main() {
    let colors = vec![RED, GREEN, BLUE];
    println!("Hello, World!");
}
```

Хотя эти вызовы *выглядят* так, как-будто содержат разный код Rust, парсер
просто видит коллекцию бессмысленных деревьев токенов. Для ясности, мы можем
заменить все эти синтаксические "черные ящики" на ⬚ и получим:

```text
bitflags! ⬚

lazy_static! ⬚

fn main() {
    let colors = vec! ⬚;
    println! ⬚;
}
```

Для повторения: парсер *ничего* не делает с ⬚; он запоминает токены, которые они
содержат, но не пытается их *понять*.

Важные выводы из этого следующие:

* Есть несколько расширений синтаксиса в Rust. Мы будем говорить *только* о
макросах, определяемых конструкцией  `macro_rules!`.

* Только из-за того, что вы видите что-то в форме `$name! $arg`, не означает,
что это на самом деле макрос; это может быть другой тип расширения синтаксиса.

* Входом в каждый макрос является одиночное безлистное дерево токенов.

* Макросы (на самом деле расширения синтаксиса) разбираются как
часть абстрактного синтаксического дерева (AST).


> **В сторону**: Из-за первого вывода некоторое описываемое ниже (включая
 следующий параграф) будет применяться к расширениям синтаксиса *в общем*. 
 [^писатель-ленив]

[^писатель-ленив]: Гораздо удобнее и быстрее писать "макрос", чем "расширение
синтаксиса".

Последний вывод особенно важен, у него  *значительные* последствия. Из-за того,
что макросы разбираются в AST, они могут появляться  **только** на том месте, в
котором они явно поддерживаются. Конкретно макросы могут появляться в следующих
местах:

* Паттерны
* Утверждения
* Выражения
* Элементы
* Элементы `impl` 

Некоторые вещи, *не* указанные в списке:

* Идентификаторы
* Варианты при поиске совпадения с образцом
* Поля структур
* Типы [^макросы-типы]

[^макросы-типы]: Макросы типа доступны в нестабильном Rust с
`#![feature(type_macros)]`; см. [Issue #27336](https://github.com/rust-
[^lang/rust/issues/27336).

Нет абсолютно, определенно *никакой* возможности использовать макросы в том
месте, которе *не* указано в первом списке.
