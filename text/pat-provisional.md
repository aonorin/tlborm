% Предварительно

Этот раздел предназначен для паттернов или техник, которые имеют сомнительную ценность, или которые могут быть *слишком* хороши для включения в основной список.

## Счеты

> **Предварительно**: нужны более привлекательные примеры. Несмотря на то что важная часть макроса `Ook!`, относящаяся к поиску совпадений с вложенными группами, *не* входящим в группы Rust, очень необычна, она может не заслуживать включения в этот раздел.

> **Заметьте**: в этой секции подразумевается понимание [спихиваемых накоплений](#push-down-accumulation) и [последовательных потребителей TT ](#incremental-tt-munchers).

```rust
macro_rules! abacus {
    ((- $($moves:tt)*) -> (+ $($count:tt)*)) => {
        abacus!(($($moves)*) -> ($($count)*))
    };
    ((- $($moves:tt)*) -> ($($count:tt)*)) => {
        abacus!(($($moves)*) -> (- $($count)*))
    };
    ((+ $($moves:tt)*) -> (- $($count:tt)*)) => {
        abacus!(($($moves)*) -> ($($count)*))
    };
    ((+ $($moves:tt)*) -> ($($count:tt)*)) => {
        abacus!(($($moves)*) -> (+ $($count)*))
    };

    // Проверка получившегося результата на ноль.
    (() -> ()) => { true };
    (() -> ($($count:tt)+)) => { false };
}

fn main() {
    let equals_zero = abacus!((++-+-+++--++---++----+) -> ());
    assert_eq!(equals_zero, true);
}
```

Эта техника может использоваться в тех случаях, когда вам нужно отслеживать изменения счетчика, начинающегося с чего-то близкого к нулю, и нужно поддерживать следующие операции:

* Инкремент на единицу.
* Декремент на единицу.
* Сравнение с нулем ( или другим фиксированным, конечным числом).

Значение *n* обозначает *n* экземпляров конкретного токена, входящего в группу.  Изменение выполняется рекурсией и [push-down accumulation](#push-down-accumulation).  Определяя используемый токен за `x`, операции выше реализуются по-следующему:

* Инкремент на единицу: совпадение с `($($count:tt)*)` заменяется на `(x $($count)*)`.
* Декремент на единицу: совпадение с `(x $($count:tt)*)` заменяется на `($($count)*)`.
* Сравнение с нулем: совпадение с `()`.
* Сравнение с единицей: совпадение с `(x)`.
* Сравнение с двойкой: совпадение с `(x x)`.
* *(и так далее...)*

Таким образом, операции с счетчиком похожи на щелканье токенов туда и обратно, как на счётах. [^счёты]

[^счёты]:
    Это крайне тонкое сравнение на самом деле скрывает *настоящую* причину такого названия: избежать *еще одной* штуки со словом "токен" в названии. Поговори со своим писателем о [семантическом насыщении](https://en.wikipedia.org/wiki/Semantic_satiation) сегодня!

    По правде говоря, эти операции *также* можно было назвать ["унарный подсчет"](https://en.wikipedia.org/wiki/Unary_numeral_system).

Если вам нужны отрицательные значения, то *-n* можно заменить на *n* экземпляров *другого* токена.  В примере выше, *+n* представлено *n* `+` токенами, а *-m* - *m* `-` токенами.

В данном случае операции немного осложняются; инкремент и декремент эффективно меняют свое значение на противоположное, если счетчик отрицательный.  Считая, что `+` и `-` представляют положительный и отрицательный токены соответственно, операции меняются следующим образом:

* Инкремент на единицу:
  * совпадение с `()`, заменяется на `(+)`.
  * совпадение с `(- $($count:tt)*)`, заменяется на `($($count)*)`.
  * совпадение с `($($count:tt)+)`, заменяется на `(+ $($count)+)`.
* Декремент на единицу:
  * совпадение с `()`, заменяется на `(-)`.
  * совпадение с `(+ $($count:tt)*)`, заменяется на `($($count)*)`.
  * совпадение с `($($count:tt)+)`, заменяется на `(- $($count)+)`.
* Сравнение с 0: совпадение с `()`.
* Сравнение с +1: совпадение с `(+)`.
* Сравнение с -1: совпадение с `(-)`.
* Сравнение с +2: совпадение с `(++)`.
* Сравнение с -2: совпадение с `(--)`.
* *(и так далее...)*

Заметьте, что пример выше объединяет некоторые из этих правил вместе (например, он объединяет инкремент `()` и `($($count:tt)+)` в инкремент `($($count:tt)*)`).

Если вы хотите достать текущее *значение* счетчика, можно использовать обычный [подсчет](../blk/README.html#counting). Для примера выше терминальные правила можно заменить следующими:

```ignore
macro_rules! abacus {
    // ...

    // This extracts the counter as an integer expression.
    (() -> ()) => {0};
    (() -> (- $($count:tt)*)) => {
        {(-1i32) $(- replace_expr!($count 1i32))*}
    };
    (() -> (+ $($count:tt)*)) => {
        {(1i32) $(+ replace_expr!($count 1i32))*}
    };
}

macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}
```

> **<abbr title="Только для этого примера">ТДЭП</abbr>**: грубо говоря, приведенная редакция `abacus!` невообразимо сложна. Ее можно заменить на гораздо более эффективную, использующую повторения, только в том случае, если вам *не* надо нигде сопоставлять паттерн со значением счетчика в макросе:
>
> ```ignore
> macro_rules! abacus {
>     (-) => {-1};
>     (+) => {1};
>     ($($moves:tt)*) => {
>         0 $(+ abacus!($moves))*
>     }
> }
> ```
