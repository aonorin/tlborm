% Анализ исходного кода

Первым этапом компиляции для программ на Rust является токенизация. На этом
этапе исходный текст преобразуется в набор токенов (*т.е.* неразделимых
лексических блоков; эквиваленты "словам" на программном языке). Rust
поддерживает различные типы токенов. Среди них, такие как:

* Идентификаторы: `foo`, `Bambous`, `self`, `we_can_dance`, `LaCaravane`, …
* Целые числа: `42`, `72u32`, `0_______0`, …
* Ключевые слова: `_`, `fn`, `self`, `match`, `yield`, `macro`, …
* Время жизни: `'a`, `'b`, `'a_rare_long_lifetime_name`, …
* Строки: `""`, `"Leicester"`, `r##"venezuelan beaver"##`, …
* Символы: `[`, `:`, `::`, `->`, `@`, `<-`, …

Необходимо выделить из приведенного списка следующее: первое, `self` является
как идентификатором, *так и* ключевым словом. Почти во всех случаях `self` - это
ключевое слово, но оно может также *трактоваться* как идентификатор, который
придет позже (вместе с проклятьями). Во-вторых, в список ключевых слов входят
разные подозрительные фразы, такие как `yield` и `macro`, которые *на самом
деле* не входят в язык, но разбираются компилятором - они зарезервированы на
будущее. Третье, в список символов *также* входят элементы, которые не
используются языком. Если взять `<-`, то это рудимент: он был удален из
грамматики, но не из словаря. Наконец, помните, что `::` - это выдающийся токен;
это не просто два токена `:`.  То же самое справедливо для всех составных
символьных токенов в Rust, начиная с Rust 1.2. [^цветы_завяли]

[^цветы_завяли]: у `@` есть назначение, о котором большинство людей забывают: он
используется в паттернах для того, чтобы связать нетерминальную часть паттерна
с именем. Даже член команды ядра Rust - тот, кто разрабатывал *конкретно* эту
главу, читая ее перед одобрением, не вспомнил, что у  `@`  есть это
назначение. Позор, какой позор.

Сравнивая с другими языками, на этом этапе у некоторых из них есть макро
уровень, а у Rust *нет*. Например, макросы C/C++  *эффективно* выполняются на
этом этапе. [^лживый-чертовски-лживый-cpp]  Вот почему работает следующий код:
[^в-cpp-это-казалось-прекрасной-идей-в-то-время]

[^лживый-чертовски-лживый-cpp]: На самом деле, препроцессор C использует другие
лексические структуры по отношению к самому C, хотя различия *очень*
незначительны.

[^в-cpp-это-казалось-прекрасной-идей-в-то-время]: *Будет* ли это работать - это
совершенно *другой* вопрос.

```c
#define SUB void
#define BEGIN {
#define END }

SUB main() BEGIN
    printf("Oh, the horror!\n");
END
```

Следующий этап - разбор, где поток токенов превращается в Абстрактное
Синтаксическое Дерево (AST). Здесь строится синтаксическая структура программы в
памяти. Например, сочетание токенов `1 + 2` преобразуется соответственно в:

```text
┌─────────┐   ┌─────────┐
│ BinOp   │ ┌╴│ LitInt  │
│ op: Add │ │ │ val: 1  │
│ lhs: ◌  │╶┘ └─────────┘
│ rhs: ◌  │╶┐ ┌─────────┐
└─────────┘ └╴│ LitInt  │
              │ val: 2  │
              └─────────┘
```

AST содержит структуру *всей* программы, хотя основывается она исключительно *на
лексической* информации. Например, компилятор может знать, что часть выражения
относится к переменной "`a`" на этом этапе, хотя он понятия не имеет, что такое
"`a`", или *откуда* ее взять.

*После того*, как было сконструировано AST, обрабатываются макросы. Однако,
прежде чем мы это обсудим, мы должны поговорить о деревьях токенов.

## Деревья токенов

Деревья токенов - это нечто среднее между токенами и AST. Для начала, *почти*
все токены являются деревьями токенов; если более конкретно, они являются
*листьями*. Есть еще одна вещь, которая тоже может быть листом дерева, но о ней
дальше.

Единственные базовые токены, которые *не* являются листьями, это токены
"группировки": `(...)`, `[...]` и `{...}`.  Эти три - *внутренние узлы* деревьев
токенов, или то, что и конструирует структуру дерева. Для конкретного примера,
эта связка токенов:

```ignore
a + b + (c + d[0]) + e
```

будет разобрана в следующие деревья токенов:

```text
«a» «+» «b» «+» «(   )» «+» «e»
          ╭────────┴──────────╮
           «c» «+» «d» «[   ]»
                        ╭─┴─╮
                         «0»
```

Помните, что это не имеет *никакого отношения* к выражениям, производимым AST;
вместо одного корневого узла, здесь *девять* деревьев токенов на корневом
уровне. Для справки, AST будет следующим:

```text
              ┌─────────┐
              │ BinOp   │
              │ op: Add │
            ┌╴│ lhs: ◌  │
┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
│ Var     │╶┘ └─────────┘ └╴│ BinOp   │
│ name: a │                 │ op: Add │
└─────────┘               ┌╴│ lhs: ◌  │
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ BinOp   │
              │ name: b │                 │ op: Add │
              └─────────┘               ┌╴│ lhs: ◌  │
                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │
                            │ op: Add │                 │ name: e │
                          ┌╴│ lhs: ◌  │                 └─────────┘
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ Index   │
              │ name: c │               ┌╴│ arr: ◌  │
              └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐ ┌─────────┐
                            │ Var     │╶┘ └─────────┘ └╴│ LitInt  │
                            │ name: d │                 │ val: 0  │
                            └─────────┘                 └─────────┘
```

Важно понимать различие между AST и деревьями токенов. При написании макросов
вам придется иметь дело с *обеими вещами* по отдельности.

Другой важный аспект: *нельзя* указать *непарную* обычную, фигурную или
квадратную скобку; также невозможно указать неправильно вложенные группы в
дереве токенов.
