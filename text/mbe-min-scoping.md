% Области видимости

Способ, которым макросам задается область видимости, интуитивно понятен.  Для начала, не так, как везде в других местах языка, макросы остаются видимыми для под-модулей.

```rust
macro_rules! X { () => {}; }
mod a {
    X!(); // определен
}
mod b {
    X!(); // определен
}
mod c {
    X!(); // определен
}
# fn main() {}
```

> **Внимание**: Для данных примеров, помните, что все они *ведут себя одинаково*, даже если модули располагаются в разных файлах.

Дальше, *также* будучи непохожим на все остальное в языке, макросы доступны *только* после их определения. Обратите внимание также, этот пример демонстрирует, что макросы не  "выплывают" из своей области видимости:

```rust
mod a {
    // X!(); // не определен
}
mod b {
    // X!(); // не определен
    macro_rules! X { () => {}; }
    X!(); // определен
}
mod c {
    // X!(); // не определен
}
# fn main() {}
```

Если быть честным, эта зависимость от лексического порядка также проявляется, если вынести макрос во вне:

```rust
mod a {
    // X!(); // не определен
}
macro_rules! X { () => {}; }
mod b {
    X!(); // определен
}
mod c {
    X!(); // определен
}
# fn main() {}
```

Однако, эта зависимость *не* проявляется внутри самих макросов:

```rust
mod a {
    // X!(); // не определен
}
macro_rules! X { () => { Y!(); }; }
mod b {
    // X!(); // определен, но Y! - не определен
}
macro_rules! Y { () => {}; }
mod c {
    X!(); // определен, как и Y!
}
# fn main() {}
```

Макросы могут быть экспортированы из модуля через атрибут `#[macro_use]` .

```rust
mod a {
    // X!(); // не определен
}
#[macro_use]
mod b {
    macro_rules! X { () => {}; }
    X!(); // определен
}
mod c {
    X!(); // определен
}
# fn main() {}
```

Помните, что это может влиять в некоторой степени причудливым образом на тот факт, что идентификаторы в макросе (включая и другие макросы внутри) разрешаются только после развертывания:

```rust
mod a {
    // X!(); // не определен
}
#[macro_use]
mod b {
    macro_rules! X { () => { Y!(); }; }
    // X!(); // определен, но Y! - не определен
}
macro_rules! Y { () => {}; }
mod c {
    X!(); // определен, как и Y!
}
# fn main() {}
```

Еще одной сложностью является то, что  `#[macro_use]`, применяемый к  `внешним контейнерам` *не* ведет себя таким образом: такие объявления фактически *поднимаются* наверх в модуле.  Поэтому, считая, что `X!` определен во внешнем контейнере `mac`:

```ignore
mod a {
    // X!(); // определен,но Y! - не определен
}
macro_rules! Y { () => {}; }
mod b {
    X!(); // определен, как и Y!
}
#[macro_use] extern crate macs;
mod c {
    X!(); // определен, как и Y!
}
# fn main() {}
```

Наконец, помните, что поведение внутри областей видимости определяется также как для *функций*, за исключением  `#[macro_use]` (для которого определяется по-другому):

```rust
macro_rules! X {
    () => { Y!() };
}

fn a() {
    macro_rules! Y { () => {"Hi!"} }
    assert_eq!(X!(), "Hi!");
    {
        assert_eq!(X!(), "Hi!");
        macro_rules! Y { () => {"Bye!"} }
        assert_eq!(X!(), "Bye!");
    }
    assert_eq!(X!(), "Hi!");
}

fn b() {
    macro_rules! Y { () => {"One more"} }
    assert_eq!(X!(), "One more");
}
# 
# fn main() {
#     a();
#     b();
# }
```

Учитывая эти правила для областей видимости, общим советом будет, ставить все макросы наверх в вашем корневом модуле, перед всеми остальными. Это гарантирует, что они будут доступны *постоянно*.
