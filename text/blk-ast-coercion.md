% AST Преобразования

Парсер Rust не очень силен в подстановках `tt`.  Проблемы могут возникнуть, когда парсер ожидает особенную грамматическую конструкцию, а *вместо этого* находит кучу подставленных `tt`.  Вместо того, чтобы попытаться их распарсить, он очень часто просто *сдается*.  В этих случаях необходимо применить AST преобразование.

```rust
# #![allow(dead_code)]
# 
macro_rules! as_expr { ($e:expr) => {$e} }
macro_rules! as_item { ($i:item) => {$i} }
macro_rules! as_pat  { ($p:pat) =>  {$p} }
macro_rules! as_stmt { ($s:stmt) => {$s} }
# 
# as_item!{struct Dummy;}
# 
# fn main() {
#     as_stmt!(let as_pat!(_) = as_expr!(42));
# }
```

Эти преобразования часто используются с [push-down accumulation] макросами для того, чтобы парсер обработал последнее выражение `tt`,  как особый вид грамматической конструкции.

Помните, что этот особый набор макросов определяется тем, во что они могут разворачиваться, а *не* тем, какие метапеременные они могут захватывать. То есть, потому что макрос не может появится на позиции типа [^issue-27245], вы не можете иметь `as_ty!` макрос.

[push-down accumulation]: pat-push-down-accumulation.html

[^issue-27245]: Смотри [Issue #27245](https://github.com/rust-lang/rust/issues/27245).
