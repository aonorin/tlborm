% Подсчет

## Повторение с заменой 

Подсчет чего-либо в макросе - удивительно хитрая задача.  Самое простое решение - использовать замену и повторяющееся сопоставление с образцом.

```rust
macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) => {0usize $(+ replace_expr!($tts 1usize))*};
}
# 
# fn main() {
#     assert_eq!(count_tts!(0 1 2), 3);
# }
```

Это прекрасно подходит для небольшого количества переменных, но скорее всего  *сломает компилятор*, когда на входе их будет около 500 или больше.  Представьте, что вывод будет выглядеть как-то так:

```ignore
0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize
```

Компилятор должен распарсить это в AST, который произведет, фактически, абсолютно несбалансированное бинарное дерево с 500+ уровнями глубины.

## Рекурсия

Старый подход - использовать рекурсию.

```rust
macro_rules! count_tts {
    () => {0usize};
    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)};
}
# 
# fn main() {
#     assert_eq!(count_tts!(0 1 2), 3);
# }
```

> **Заметьте**: По состоянию на `rustc` 1.2, у компилятора появляются  *серьезные* проблемы с производительностью, если большое число целочисленных переменных неизвестного типа должны пройти через выведение.  Мы используем здесь явно переменные типа `usize` для избежания этого.
>
> Если такой вариант не подходит (например, когда тип должен подставляться), вы можете помочь компилятору, используя  `as` (*например* `0 as $ty`, `1 as $ty`, *и т.д.*).

Этот подход *работает*, но довольно быстро достигнется лимит рекурсии.  В отличие от подхода с повторениями, вы можете расширить количество переменных на входе сопоставлением множества токенов за один раз.

```rust
macro_rules! count_tts {
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt
     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt
     $($tail:tt)*)
        => {20usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $($tail:tt)*)
        => {10usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $($tail:tt)*)
        => {5usize + count_tts!($($tail)*)};
    ($_a:tt
     $($tail:tt)*)
        => {1usize + count_tts!($($tail)*)};
    () => {0usize};
}

fn main() {
    assert_eq!(700, count_tts!(
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        // Повторение ломается где-то после этого места
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
    ));
}
```

Такая формулировка будет работать вплоть до ~1,200 значений.

## Длина среза

Третий подход к решению проблемы — помочь компилятору сконструировать неглубокий AST, который не приведет к переполнению стека.  Это можно сделать, сконструировав переменную массива и вызвав метод `len`.

```rust
macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) => {<[()]>::len(&[$(replace_expr!($tts ())),*])};
}
# 
# fn main() {
#     assert_eq!(count_tts!(0 1 2), 3);
# }
```

Этот подход протестирован на коде длиной до 10000 токенов и, возможно, будет работать для гораздо более длинного кода.  *Обратной стороной* является то, что в Rust 1.2 он *не может* быть использован для представления константного выражения.  Хотя результат может быть оптимизирован до простой константы (при билде в режиме дебага он компилируется вниз для загрузки из памяти), он все еще не может использоваться в качестве константы (значение `const` или точный размер массива).

Однако, если необходим неконстантный подсчет, это один из самых предпочтительных методов.

## Подсчет через Enum

Этот подход может использоваться, если вам нужно посчитать набор взаимно различных идентификаторов. Необходимо добавить, что результат этого подхода используется как константа.

```rust
macro_rules! count_idents {
    ($($idents:ident),* $(,)*) => {
        {
            #[allow(dead_code, non_camel_case_types)]
            enum Idents { $($idents,)* __CountIdentsLast }
            const COUNT: u32 = Idents::__CountIdentsLast as u32;
            COUNT
        }
    };
}
# 
# fn main() {
#     const COUNT: u32 = count_idents!(A, B, C);
#     assert_eq!(COUNT, 3);
# }
```

У этого метода есть два недостатка.  Первый, как приведено выше, - он может считать *только* валидные идентификаторы  (которые, к тому же, не являются ключевыми словами), и он не позволяет идентификаторам повторяться.

Второй недостаток - этот подход *не совсем* чист, имея ввиду, что если вместо одного из идентификаторов на входе вы используете  `__CountIdentsLast`, макрос сломается из-за дублирования вариантов в `enum`.
