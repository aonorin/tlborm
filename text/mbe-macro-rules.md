% macro_rules!

Имея все это в голове, мы можем представить сам  `macro_rules!`.  Как раньше было замечено, `macro_rules!` это *само по себе* расширение синтаксисa, имея ввиду, что это *технически* не часть синтаксиса  Rust. Он использует следующую форму:

```ignore
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}
```

Должно быть *по крайней мере* одно правило, и вы можете опустить точку с запятой после последнего правила.

Каждое "`rule`" выглядит так:

```ignore
    ($pattern) => {$expansion}
```

Вообще, круглые и фигурные скобки могут обозначать любой тип групп, но принято, что круглые скобки ставят вокруг паттерна (pattern), а фигурные - вокруг расширения (expansion).

Если вам интересно, сам  `macro_rules!` расширяется в ... *ничего*.  По крайней мере, хоть что-то не появляется в AST; скорее, он манипулирует внутренними структурами компилятора для регистрации макроса.  Таким образом, вы можете  *технически* использовать `macro_rules!` в любой позиции, где  пустое расширение является валидным.

## Совпадения

Когда макрос вызывается, интерпретатор `macro_rules!` идет по правилам, одно за другим в лексическом порядке. Для каждого правила , он пытается определить совпадает ли содержание на входе с `pattern` правила.  Паттерн должен совпасть *целиком*, чтобы вход считался совпавшим.

Если вход совпадает с паттерном, вызов заменяется на  `expansion`; иначе, пробуется следующее правило.  Если ни одно из правил не совпало, расширение макроса вызывает ошибку.

Самый простой пример пустого паттерна:

```ignore
macro_rules! four {
    () => {1 + 3};
}
```

Это совпадет тогда и только тогда, когда вход тоже будет пустым (*например* `four!()`, `four![]` or `four!{}`).

Заметьте, что символы для группировки (скобки) при вызове макроса *не* совпадают.  Это означает, что вы можете вызывать макрос как  `four![]`, и он все равно совпадет.  Только *содержимое* на входе рассматривается.

Паттерны также могут содержать буквенные деревья, которые должны полностью совпасть. Это делается простым написанием нормальных деревьев. Например, для того, чтобы совпасть с деревом выражения  `4 fn ['spang "whammo"] @_@`, вы будете использовать:

```ignore
macro_rules! gibberish {
    (4 fn ['spang "whammo"] @_@) => {...};
}
```

Вы можете использовать любые деревья выражений, какие сможете написать.

## Захват

Патерны также могут содержать захваты (captures).  Это позволяет проверять вход на совпадение, основываясь на некоторой общей категории грамматики, получая преобразованный в переменную результат, который в дольнейшем может быть подствален на выход.

Захваты обозначаются как доллар (`$`), за которым следуют идентификатор, двоеточие (`:`), и наконец тип захвата, который должен быть одним из следующих:

* `item`: объект, как, например, функция, структура, модуль, и т.д.
* `block`: блок  (например, блок утверждений или выражений, окруженный фигурными скобками)
* `stmt`: утверждение
* `pat`: паттерн
* `expr`: выражение
* `ty`: тип
* `ident`: идентификатор
* `path`: путь (например, `foo`, `::std::mem::replace`, `transmute::<_, int>`, …)
* `meta`: мета объект; вещи которые идут внутри атрибутов `#[...]` и `#![...]` 
* `tt`: одиночное дерево лексем

Напрмер, вот макрос, который захватывает вход как выражение:

```ignore
macro_rules! one_expression {
    ($e:expr) => {...};
}
```

Эти захваты по максимуму используют парсер компилятора Rust, всегда обеспечивая "корректность".  Захват `expr`  будет *всегда* захватывать полное, валидное выражение для той версии Rust, под которую он компилируется.

Вы можете смешивать буквенные деревья и захваты с ограничениями (объясняется ниже).

Захват `$name:kind` может быть заменен в расширении написанием  `$name`.  Например:

```ignore
macro_rules! times_five {
    ($e:expr) => {5 * $e};
}
```

В большинстве своем как и расширения макроса, захваты заменяются на полные узлы AST.  Это означает, что неважно, какие выражения из лексем захвачены в `$e`, оно будет интерпретироваться как одно, законченное выражение.

У вас также может быть несколько захватов в одном паттерне:

```ignore
macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};
}
```

## Повторения

Паттерны могут содержать повторения. Это позволяет определить совпадения для связки лексем.  Общая форма для этого - `$ ( ... ) sep rep`.

* `$` - знак доллара.
* `( ... )` повторяющийся паттерн в скобках .
* `sep` это *дополнительный* разделитель.  Обычно, как пример, `,`, и `;`.
* `rep` это *требуемый* контроль повторений. В данный момент, это может быть  *или* `*` (обозначающий ноль или больше повторений) или `+` (обозначающий одно или больше повторений). Вы не можете написать "ноль или одно" или любое другое более конкретное число повторений.

Повторения могут содержать любые валидные паттерны, включая деревья выражений, захваты, и другие повторения.

Повторения используют такой же синтаксис и в расширении.

Например, внизу макрос, который форматирует каждый элемент как строку. Он ищет совпадения с нулем или больше выражений, разделенных запятой, и расширяет их в выражение, которое конструирует вектор.

```rust
macro_rules! vec_strs {
    (
        // Начало повторения:
        $(
            // Каждое повторение должно содержать выражение...
            $element:expr
        )
        // ...разделенное запятыми...
        ,
        // ...ноль или больше раз.
        *
    ) => {
        // Заключаем разложение в скобки (блок) таким образом, что
        // мы можем использовать несколько утверждений.
        {
            let mut v = Vec::new();

            // Начало повторения:
            $(
                // Каждое повторение будет содержать следующее утверждение, в котором
                // $element будет заменен на соответствующее выражение.
                v.push(format!("{}", $element));
            )*

            v
        }
    };
}
# 
# fn main() {
#     let s = vec_strs![1, "a", true, 3.14159f32];
#     assert_eq!(&*s, &["1", "a", "true", "3.14159"]);
# }
```
