% macro_rules!

Держа все это в голове, мы можем представить сам  `macro_rules!`.  Как раньше было замечено, `macro_rules!` это *само по себе* расширение синтаксисa, имея ввиду, что это *технически* не часть синтаксиса  Rust. Он использует следующую форму:

```ignore
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}
```

Должно быть *по крайней мере* одно правило. Вы можете опустить точку с запятой после последнего правила.

Каждое "`rule`" выглядит так:

```ignore
    ($pattern) => {$expansion}
```

Вообще, круглые и фигурные скобки могут обозначать любой тип групп, но принято, что круглые скобки ставят вокруг паттерна (pattern), а фигурные - вокруг развертывания (expansion).

Если вам интересно, сам  `macro_rules!` разворачивается в... *ничто*.  По крайней мере, хоть что-то не появляется в AST; скорее, он манипулирует внутренними структурами компилятора для регистрации макроса.  Таким образом, *формально* вы можете использовать `macro_rules!` в любой позиции, в которой пустое развертывание является валидным.

## Совпадения

Когда макрос вызывается, интерпретатор `macro_rules!` проходит все правила, одно за другим в лексическом порядке. Для каждого правила он пытается определить, совпадает ли содержание на входе с `паттерном` правила.  Паттерн должен совпасть *целиком*, чтобы вход считался совпавшим.

Если вход совпадает с паттерном, вызов заменяется на `развертывание`; иначе, пробуется следующее правило.  Если ни одно из правил не совпало, развертывание макроса вызывает ошибку.

Самый простой пример пустого паттерна:

```ignore
macro_rules! four {
    () => {1 + 3};
}
```

Этот паттерн считается совпавшим с образцом тогда и только тогда, когда вход тоже будет пустым (*например* `four!()`, `four![]` or `four!{}`).

Заметьте, что символы для группировки (скобки) при вызове макроса *не* сопоставляются с образцом. Это означает, что вы можете вызывать макрос как  `four![]`, и он все равно совпадет.  Только *содержимое* на входе рассматривается.

Паттерны также могут содержать деревья литеральных токенов, которые должны полностью совпасть с образцом. Это делается просто написанием деревьев токенов в обычной форме. Например, для того, чтобы совпадение с выражением  `4 fn ['spang "whammo"] @_@` выполнилось, вам нужно написать:

```ignore
macro_rules! gibberish {
    (4 fn ['spang "whammo"] @_@) => {...};
}
```

Вы можете использовать любые деревья токенов, какие сможете написать.

## Захват

Патерны также могут содержать метапеременные (captures).  Это позволяет проверять вход на совпадение с образцом, основываясь на некоторой общей категории грамматики, получая преобразованный в переменную результат, который в дальнейшем может быть подставлен на выход.

Метапеременные обозначаются долларом (`$`), за которым следуют идентификатор, двоеточие (`:`), и наконец тип метапеременной, который должен быть одним из следующих:

* `item`: объект, например, функция, структура, модуль, и т.д.
* `block`: блок  (например, блок утверждений или выражений, окруженный фигурными скобками)
* `stmt`: утверждение
* `pat`: паттерн
* `expr`: выражение
* `ty`: тип
* `ident`: идентификатор
* `path`: путь (например, `foo`, `::std::mem::replace`, `transmute::<_, int>`, …)
* `meta`: мета объект; вещи которые идут внутри атрибутов `#[...]` и `#![...]` 
* `tt`: одиночное дерево токенов

Например, вот макрос, который захватывает метапеременную на входе как выражение:

```ignore
macro_rules! one_expression {
    ($e:expr) => {...};
}
```

Эти метапеременные по максимуму используют парсер компилятора Rust, всегда обеспечивая "корректность".  Метапеременная типа `expr`  будет *всегда* захватывать полное, валидное выражение для той версии Rust, под которой оно компилируется.

Вы можете смешивать деревья литеральных токенов и метапеременные в определенных пределах (объясняются ниже).

Метапеременная `$name:kind` может быть заменена в развертывании написанием  `$name`.  Как пример:

```ignore
macro_rules! times_five {
    ($e:expr) => {5 * $e};
}
```

В большинстве своем, как и развертывания макроса, метапеременные заменяются на полные узлы AST.  Это означает, что неважно, какие выражения из токенов захвачены в метапеременной `$e`, она будет интерпретироваться как одно, законченное выражение.

У вас также может быть несколько метапеременных в одном паттерне:

```ignore
macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};
}
```

## Повторения

Паттерны могут содержать повторения. Это позволяет определить совпадения для связки токенов.  Общая форма для этого - `$ ( ... ) sep rep`.

* `$` - знак доллара.
* `( ... )` - повторяющийся паттерн в скобках .
* `sep` - *дополнительный* разделитель.  Например: `,` и `;`.
* `rep` - *требуемый* контроль повторений. В данный момент это может быть  *или* `*` (обозначающая ноль или более повторений) или `+` (обозначающий одно или более повторений). Вы не можете написать "ноль или одно" или любое другое более конкретное число повторений.

Повторения могут содержать любые валидные паттерны, включая деревья литеральных токенов, метапеременные и другие повторения.

Повторения используют такой же синтаксис и в развертывании.

Например, внизу макрос, который форматирует каждый элемент как строку. Он ищет совпадения с нулем или более выражений, разделенных запятой, и разворачивает их в выражение, которое конструирует вектор.

```rust
macro_rules! vec_strs {
    (
        // Начало повторения:
        $(
            // Каждое повторение должно содержать выражение...
            $element:expr
        )
        // ...разделенное запятыми...
        ,
        // ...ноль или более раз.
        *
    ) => {
        // Заключаем разложение в скобки (блок) таким образом, что
        // мы можем использовать несколько утверждений.
        {
            let mut v = Vec::new();

            // Начало повторения:
            $(
                // Каждое повторение будет содержать следующее утверждение, в котором
                // $element будет заменен на соответствующее выражение.
                v.push(format!("{}", $element));
            )*

            v
        }
    };
}
# 
# fn main() {
#     let s = vec_strs![1, "a", true, 3.14159f32];
#     assert_eq!(&*s, &["1", "a", "true", "3.14159"]);
# }
```
